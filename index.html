<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Burguer Horror üçî</title>
<style>
body {
  margin: 0;
  background: linear-gradient(45deg, yellow, lime, pink);
  transform: rotate(2deg);
  font-family: "Comic Sans MS", cursive;
  color: magenta;
  overflow-x: scroll;
  text-align: justify;
  transition: background-color 0.2s ease-in-out;
}

header {
  background: red;
  color: yellow;
  text-align: center;
  font-size: 50px;
  padding: 40px;
  transform: rotate(-4deg);
  text-shadow: 5px 5px 5px blue;
}

section {
  background: rgba(255,255,255,0.2);
  border: 8px dashed purple;
  padding: 30px;
  margin: 50px;
  width: 80%;
  transform: rotate(3deg);
}

img {
  width: 300px;
  height: 180px;
  transform: rotate(-15deg) skew(10deg);
  margin: 40px;
  border: 10px ridge orange;
}

button {
  background: linear-gradient(to right, red, blue);
  color: yellow;
  padding: 20px;
  border-radius: 50%;
  transform: rotate(10deg);
  font-size: 20px;
  margin-left: 70%;
  cursor: pointer;
}

footer {
  background: green;
  color: white;
  text-align: center;
  padding: 40px;
  font-size: 25px;
  transform: rotate(-2deg);
}

.marquee {
  font-size: 35px;
  background: black;
  color: cyan;
  transform: rotate(5deg);
}

li {
  transform: rotate(-5deg);
  font-size: 25px;
}

h2 {
  color: red;
  font-size: 40px;
  transform: rotate(6deg);
}

input, textarea {
  display: block;
  margin: 20px auto;
  width: 60%;
  padding: 15px;
  border: 5px dotted red;
  transform: rotate(-3deg);
  background-color: yellow;
  color: blue;
  font-size: 20px;
}

/* --- Efeitos visuais --- */
.flash {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
  z-index: 9999;
  transition: opacity 0.3s ease-in-out;
}

/* Bot√£o "X" que foge */
#closeX {
  position: fixed;
  font-size: 120px;
  font-weight: bold;
  color: red;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(5deg);
  cursor: pointer;
  opacity: 0;
  z-index: 10000;
  transition: all 0.1s ease-in-out;
}

/* Tela preta (blackout) ‚Äî criada dinamicamente se n√£o existir */
#bh_blackout {
  position: fixed;
  top:0; left:0; right:0; bottom:0;
  background:black;
  z-index: 20000;
  opacity:0;
  pointer-events:none;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:28px;
  transition: opacity .2s ease-in-out;
}

/* Popups in-page estilo terminal (criadas dinamicamente) */
.bh_term {
  position: fixed;
  width: 360px;
  height: 160px;
  background: #081420;
  color: #bfefff;
  padding: 12px;
  border: 3px solid #0ff;
  font-family: monospace;
  font-size: 14px;
  z-index: 21000;
  box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  overflow: hidden;
  white-space: pre-wrap;
}
</style>
</head>
<body>

<!-- Camadas de flash e pop-ups -->
<div class="flash" id="flash"></div>
<div id="closeX">X</div>

<header>üçî BURGUER HORROR üçü</header>

<marquee class="marquee" scrollamount="20">
üî• Promo√ß√£o: Pe√ßa 1 leve 0,5 (se o sistema deixar) üî•
</marquee>

<section>
  <h2>Nosso Card√°pio Torturado:</h2>
  <ul>
    <li>Hamb√∫rguer de Sardinha com Chocolate - R$59,90</li>
    <li>Batata Frita Crua - R$22,00</li>
    <li>Refrigerante sem g√°s e quente - R$15,00</li>
  </ul>

  <h3 style="color:red; text-align:center; transform:rotate(4deg);">
    Fa√ßa seu pedido (se conseguir üòà):
  </h3>
  <textarea id="pedido" rows="4" placeholder="Digite seu pedido aqui..."></textarea>
</section>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Hamburger_%28black_bg%29.jpg/640px-Hamburger_%28black_bg%29.jpg" alt="hamburguer horror">

<button id="pedidoBtn">Fazer Pedido (ou n√£o)</button>

<footer>
¬© 2025 Burguer Horror - ‚ÄúFeito com descuido e ketchup azedo‚Äù
</footer>

<audio id="risada" src="https://www.myinstants.com/media/sounds/hahaha_1.mp3"></audio>

<script>
/* -------------------------
   Seu script original (mantive exatamente)
   ------------------------- */
let clickCount = 0;
let contador = 0;

// --- Campo de pedido bugado ---
const campoPedido = document.getElementById('pedido');
campoPedido.addEventListener('input', () => {
  contador++;
  if (contador >= 5) {
    campoPedido.value = campoPedido.value.slice(0, -3);
    contador = 0;
  }
});

// --- Flash e bot√µes ---
const flash = document.getElementById('flash');
const closeX = document.getElementById('closeX');
const risada = document.getElementById('risada');

// Fun√ß√£o para piscar colorido ao clicar no bot√£o de pedido
function flashColorido() {
  const colors = ['red', 'blue', 'yellow', 'lime', 'pink', 'purple'];
  let i = 0;
  const interval = setInterval(() => {
    flash.style.background = colors[i % colors.length];
    flash.style.opacity = '1';
    setTimeout(() => flash.style.opacity = '0', 150);
    i++;
    if (i > 12) clearInterval(interval);
  }, 200);
}

// Fun√ß√£o principal para mostrar tela com X que foge
function showScreen(color, nextColor = null) {
  flash.style.background = color;
  flash.style.opacity = '1';
  flash.style.pointerEvents = 'auto';
  closeX.style.opacity = '1';
  closeX.style.pointerEvents = 'auto';

  // Muda a cor do X conforme a cor de fundo
  if (color === 'red') {
    closeX.style.color = 'black';
  } else {
    closeX.style.color = 'red';
  }

  risada.play();

  const moverX = () => {
    const newX = Math.random() * (window.innerWidth - 150);
    const newY = Math.random() * (window.innerHeight - 150);
    closeX.style.left = newX + 'px';
    closeX.style.top = newY + 'px';
  };
  closeX.addEventListener('mousemove', moverX);

  const fechar = () => {
    flash.style.opacity = '0';
    closeX.style.opacity = '0';
    flash.style.pointerEvents = 'none';
    closeX.style.pointerEvents = 'none';
    closeX.removeEventListener('mousemove', moverX);
    closeX.removeEventListener('click', fechar);

    if (nextColor) {
      setTimeout(() => showScreen(nextColor), 1000);
    }
  };
  closeX.addEventListener('click', fechar);
}

// Tela branca ‚Üí verde ‚Üí vermelha (todas com X)
function iniciarSequencia() {
  showScreen('white', 'green');
  setTimeout(() => {
    closeX.addEventListener('click', () => {
      setTimeout(() => showScreen('red'), 10000);
    });
  }, 1000);
}

// Mostra a tela branca a cada 20 segundos
setInterval(iniciarSequencia, 20000);

// --- Clique no bot√£o de pedido ---
document.getElementById('pedidoBtn').addEventListener('click', () => {
  clickCount++;
  if (clickCount === 1) {
    flashColorido();
    alert('üí• Tenta clicar novamente hahahahha üí•');
  } else if (clickCount === 2) {
    location.reload();
  }
});
</script>

<script>
/* -------------------------
   C√≥digo ADICIONAL (s√≥ adiciona comportamento do "Confirmar pedido")
   ‚Äî N√ÉO altera design, N√ÉO remove nem substitui suas fun√ß√µes.
   ------------------------- */

(function(){
  // IDs e nomes pr√≥prios para evitar qualquer conflito
  const BTN_ID = 'bh_confirm_btn';
  const POP_CLASS = 'bh_term';
  const BLACKOUT_ID = 'bh_blackout';
  const POP_COUNT = 8;        // quantos pop-ups mostrar
  const BLACKOUT_MS = 10000;  // 10 segundos

  // cria e injeta bot√£o Confirmar logo ap√≥s o textarea (sem alterar seu markup original)
  function injectConfirmButton() {
    const textarea = document.getElementById('pedido');
    if (!textarea) return;
    // se j√° existir, n√£o recriar
    if (document.getElementById(BTN_ID)) return;
    const btn = document.createElement('button');
    btn.id = BTN_ID;
    btn.type = 'button';
    btn.textContent = 'Confirmar Pedido';
    // deixar o bot√£o sem estilos inline al√©m do necess√°rio; ele herdar√° seu estilo padr√£o de button
    btn.style.display = 'block';
    btn.style.margin = '16px auto';
    btn.style.padding = '12px 18px';
    // insere depois do textarea
    textarea.parentNode.insertBefore(btn, textarea.nextSibling);
  }

  // cria blackout overlay se n√£o existir
  function ensureBlackout() {
    let b = document.getElementById(BLACKOUT_ID);
    if (!b) {
      b = document.createElement('div');
      b.id = BLACKOUT_ID;
      b.innerHTML = '<div style="text-align:center">Aguarde... processando</div>';
      // estilo inline para garantir n√£o mexer no CSS existente
      b.style.position = 'fixed';
      b.style.left = '0';
      b.style.top = '0';
      b.style.width = '100%';
      b.style.height = '100%';
      b.style.background = 'black';
      b.style.color = 'white';
      b.style.display = 'flex';
      b.style.alignItems = 'center';
      b.style.justifyContent = 'center';
      b.style.zIndex = '22000';
      b.style.opacity = '0';
      b.style.pointerEvents = 'none';
      b.style.transition = 'opacity 0.2s ease-in-out';
      document.body.appendChild(b);
    }
    return b;
  }

  // playBeep seguro (baixo volume). Retorna function para parar sequ√™ncia
  function startBeepSequence() {
    let ctx;
    try {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      return { stop: ()=>{} };
    }
    const gain = ctx.createGain();
    gain.gain.value = 0.02; // volume muito baixo (seguro)
    gain.connect(ctx.destination);

    // cria v√°rios osciladores sequenciais para evitar estar tocando um por 10s cont√≠nuos
    const oscillators = [];
    let stopped = false;
    const schedule = () => {
      if (stopped) return;
      const o = ctx.createOscillator();
      o.type = 'sine';
      o.frequency.value = 1800 + Math.random()*600; // varia√ß√£o suave
      o.connect(gain);
      o.start();
      oscillators.push(o);
      // parar depois de 200ms
      setTimeout(()=> {
        try { o.stop(); } catch(e) {}
      }, 200);
      // agendar pr√≥ximo beep em ~200ms
      setTimeout(schedule, 200);
    };
    schedule();

    return {
      stop: () => {
        stopped = true;
        oscillators.forEach(o => { try{o.stop();}catch(e){} });
        try { ctx.close(); } catch(e){}
      }
    };
  }

  // cria popups in-page (n√£o abre janelas)
  function createPopups(msg, count) {
    const created = [];
    for (let i=0;i<count;i++) {
      const d = document.createElement('div');
      d.className = POP_CLASS;
      // posi√ß√£o rand√¥mica dentro da viewport, com margem
      const left = 20 + Math.random() * Math.max(0, window.innerWidth - 420);
      const top  = 20 + Math.random() * Math.max(0, window.innerHeight - 220);
      d.style.left = left + 'px';
      d.style.top  = top + 'px';
      d.style.zIndex = 23000 + i;
      d.innerHTML = `<strong>cmd.exe</strong>\n${msg}`;
      document.body.appendChild(d);

      // efeito de "digitando" nos textos
      let dots = 0;
      d._interval = setInterval(()=> {
        dots = (dots+1)%4;
        d.innerHTML = `<strong>cmd.exe</strong>\n${msg}` + '.'.repeat(dots);
      }, 300);

      created.push(d);
    }
    return created;
  }

  function removePopups(list) {
    list.forEach(p => {
      if (p._interval) clearInterval(p._interval);
      if (p.parentNode) p.parentNode.removeChild(p);
    });
  }

  // bloquear a fun√ß√£o iniciarSequencia durante blackout: monkey-patch leve e restaur√°vel
  const originalIniciar = window.iniciarSequencia;
  let patched = false;
  function patchIniciarBlocker() {
    if (patched) return;
    patched = true;
    window.iniciarSequencia = function() {
      // se blackout ativo, n√£o chama original
      if (window.__BH_confirm_blackout_active) return;
      return originalIniciar && originalIniciar();
    };
  }
  function restoreIniciar() {
    if (!patched) return;
    patched = false;
    if (originalIniciar) window.iniciarSequencia = originalIniciar;
  }

  // handler do clique Confirmar Pedido
  function onConfirmClick(e) {
    // se j√° ativo, ignore
    if (window.__BH_confirm_blackout_active) return;
    window.__BH_confirm_blackout_active = true;

    // impedir que a sequ√™ncia de telas brancas apare√ßa enquanto blackout
    patchIniciarBlocker();

    // cria blackout overlay
    const blackout = ensureBlackout();
    blackout.style.opacity = '1';
    blackout.style.pointerEvents = 'auto';

    // criar popups
    const msg = 'VISH ACONTECEU ALGUMA COISA';
    const pops = createPopups(msg, POP_COUNT);

    // iniciar beeps moderados
    const beeper = startBeepSequence();

    // ap√≥s 10s, limpar tudo
    setTimeout(()=> {
      // parar beeps
      try { beeper.stop(); } catch(e){}
      // esconder blackout
      blackout.style.opacity = '0';
      blackout.style.pointerEvents = 'none';
      // remover popups
      removePopups(pops);
      // restaurar iniciarSequencia
      window.__BH_confirm_blackout_active = false;
      restoreIniciar();
    }, BLACKOUT_MS);
  }

  // injeta bot√£o e listener no load
  function init() {
    injectConfirmButton();
    const btn = document.getElementById(BTN_ID) || document.getElementById('confirmarBtn') || document.getElementById('bh_confirm_btn');
    const ourBtn = document.getElementById(BTN_ID);
    if (ourBtn) {
      ourBtn.addEventListener('click', onConfirmClick);
    } else {
      // se por algum motivo n√£o encontrou, tentar criar listener em elemento com id 'confirmarBtn' (caso tenha sido inserido antes)
      const fallback = document.getElementById('confirmarBtn');
      if (fallback) fallback.addEventListener('click', onConfirmClick);
    }
    // assegurar blackout DOM
    ensureBlackout();
  }

  // esperar DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else init();

})();
</script> 
<script>
  (function(){
    // CONFIGURA√á√ïES (ajuste se quiser)
    const BTN_ID = 'confirmarBtn'; // id do bot√£o que aciona (ajuste se necess√°rio)
    const POP_CLASS = 'bh_fullfill_popup';
    const POP_W = 260;             // largura popup
    const POP_H = 140;             // altura popup
    const INTERVAL_MS = 90;        // intervalo entre surgimento de popups (ms)
    const MAX_POPUPS = 400;        // limite de seguran√ßa
    const TARGET_MULTIPLIER = 1.15; // queremos area total de popups >= viewport * multiplier
  
    // flag de bloqueio para n√£o rodar m√∫ltiplas execu√ß√µes simult√¢neas
    if (window.__bh_fill_running === undefined) window.__bh_fill_running = false;
  
    // cria um popup "cmd-like" bagun√ßado na posi√ß√£o dada
    function makePopup(msg, left, top, z, rot) {
      const d = document.createElement('div');
      d.className = POP_CLASS;
      Object.assign(d.style, {
        position: 'fixed',
        left: (left | 0) + 'px',
        top: (top | 0) + 'px',
        width: POP_W + 'px',
        height: POP_H + 'px',
        background: '#041420',
        color: '#bfefff',
        fontFamily: 'monospace',
        fontSize: '13px',
        padding: '10px',
        border: '3px solid #0ff',
        boxSizing: 'border-box',
        zIndex: z,
        transform: `rotate(${rot}deg)`,
        boxShadow: '0 10px 30px rgba(0,0,0,0.6)',
        opacity: '0',
        transition: 'opacity .18s ease-in-out, transform .18s linear'
      });
      d.innerHTML = `<strong>cmd.exe</strong>\n${msg}`;
      document.body.appendChild(d);
      // aparecer com fade-in
      requestAnimationFrame(()=> d.style.opacity = '1');
      return d;
    }
  
    // remove popups (usado opcionalmente)
    function removePopups(list) {
      list.forEach(el => {
        try { el.style.opacity = '0'; setTimeout(()=> el.remove(), 220); } catch(e){}
      });
    }
  
    // cria a grade bagun√ßada preenchendo a tela visualmente
    async function fillScreenChaotic() {
      if (window.__bh_fill_running) return;
      window.__bh_fill_running = true;
  
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const viewArea = vw * vh;
      const targetArea = viewArea * TARGET_MULTIPLIER;
  
      const created = [];
      let totalArea = 0;
      let i = 0;
  
      // Come√ßamos criando popups um a um, com posi√ß√µes aleat√≥rias
      while ((totalArea < targetArea) && i < MAX_POPUPS) {
        // escolher posi√ß√£o pseudo-aleat√≥ria priorizando cobertura central e laterais
        const left = Math.random() * (vw - POP_W);
        const top  = Math.random() * (vh - POP_H);
        const rot  = (Math.random()-0,2) * 40; // -20 a 20 graus
        const z    = 60000 + i;
        const msg  = 'VISH ACONTECEU ALGUMA COISA';
        const el = makePopup(msg, left, top, z, rot);
  
        created.push(el);
        totalArea += POP_W * POP_H; // soma √°rea (mesmo com sobreposi√ß√£o, √© estimativa)
  
        i++;
        // espera antes de criar o pr√≥ximo pra efeito "de pouco em pouco"
        await new Promise(res => setTimeout(res, INTERVAL_MS));
      }
  
      // garantia extra: se fizermos poucos pops por causa de viewport pequena, preencher com mais
      if (totalArea < targetArea && i >= MAX_POPUPS) {
        // criar pequenos pop-ups at√© visualmente encher
        const smallW = Math.max(80, Math.floor(POP_W/2));
        const smallH = Math.max(60, Math.floor(POP_H/2));
        for (let s = 0; totalArea < targetArea && s < 500; s++) {
          const left = Math.random() * (vw - smallW);
          const top  = Math.random() * (vh - smallH);
          const rot  = (Math.random()-0.5) * 40;
          const z    = 65000 + s;
          const d = document.createElement('div');
          Object.assign(d.style, {
            position:'fixed', left:left+'px', top:top+'px', width:smallW+'px', height:smallH+'px',
            background:'#001116', color:'#aaffcc', fontFamily:'monospace', fontSize:'11px',
            padding:'6px', border:'2px solid #33f', boxSizing:'border-box', zIndex: z, transform:`rotate(${rot}deg)`,
            boxShadow:'0 6px 18px rgba(0,0,0,0.6)', opacity:'0', transition:'opacity .15s ease-in-out'
          });
          d.innerHTML = `<strong>cmd.exe</strong>\nVISH ACONTECEU ALGUMA COISA`;
          document.body.appendChild(d);
          requestAnimationFrame(()=> d.style.opacity = '1');
          created.push(d);
          totalArea += smallW * smallH;
          await new Promise(res => setTimeout(res, INTERVAL_MS/2));
        }
      }
  
      // Pronto ‚Äî tela preenchida visualmente. Mantemos os popups vis√≠veis.
      // N√ÉO removemos automaticamente (assim fica ruim para o usu√°rio).
      // Se quiser que sumam depois de X segundos, posso adicionar.
  
      window.__bh_fill_running = false;
      // op√ß√£o: retornar a lista criada
      return created;
    }
  
    // anexa ao bot√£o confirmar (sem criar bot√£o, apenas liga o handler)
    function attachHandler() {
      const btn = document.getElementById(BTN_ID);
      if (!btn) {
        console.warn('[BH] Bot√£o "'+BTN_ID+'" n√£o encontrado. Diga o id correto se precisar.');
        return;
      }
      btn.addEventListener('click', (e) => {
        // evita reentr√¢ncia
        if (window.__bh_fill_running) return;
        // iniciar a sequ√™ncia
        fillScreenChaotic();
      });
    }
  
    // inicia ao carregar
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', attachHandler);
    } else attachHandler();
  
  })();
  </script>
  
</body>
</html>
